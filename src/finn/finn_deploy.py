import socket
import json
import paramiko
from paramiko import SSHClient, AutoAddPolicy, SSHException
import torch
import os
import time
import numpy as np

class RemotePynq:
    """This class represents a remote PYNQ board, allowing the user to deploy and execute neural network models on it."""
    def __init__(self, local_path, remote_path, board):
        """
        :param local_path: The path to the "deploy" folder generated by the step_deployment_package of the build
        :param remote_path: The path where the "deploy folder is sent on the Pynq board"
        :param board: A class that contains the pynq board information
        """
        assert os.path.exists(local_path), f"The specified path does not exist: {local_path}"
        self.local_path = local_path
        self.remote_path = remote_path
        self.board = board

    @staticmethod
    def _print_ssh(buffer: str, end: str="\n"):
        """
        Prints a string buffer to the console with a different color (through ANSI escape sequences),
        to differentiate between local and remote output.
        :param buffer (str): The string to print to the console.
        :param end (str, optional): The string to append to the end of the printed output. Defaults to "\n".
        :return: None
        """
        # Set text color in terminal to green (through ANSI escape sequences):
        green_begin = '\033[92m'
        green_end = '\033[0m'
        print(f"{green_begin}{buffer}{green_end}", end=end)

    def deploy_to_pynq(self):
        """Send the "deploy" folder generated by FINN to the board"""

        # Remove local input.npy and output.npy if exist
        for file in ("input.npy", "output.npy"):
            if os.path.exists(os.path.join(self.local_path, "driver", file)):
                os.remove(os.path.join(self.local_path, "driver", file))

        # Find relative path of all files in the 'deploy' directory (and subdirectories to be created on the board)
        files_to_transfer = []
        directories_to_create = []
        for dir_path, dir_names, filenames in os.walk(self.local_path):
            for dir_name in dir_names:
                directories_to_create.append(os.path.relpath(os.path.join(dir_path, dir_name), self.local_path))
            for filename in filenames:
                relative_path = os.path.relpath(os.path.join(dir_path, filename), self.local_path)
                files_to_transfer.append(relative_path)

        print("Copy deploy folder to the board...", end="")
        # Set up SSH client
        with SSHClient() as ssh:
            ssh.set_missing_host_key_policy(AutoAddPolicy())
            # Connect to the board with a timeout of 5 seconds
            ssh.connect(self.board.ip, self.board.port, self.board.username, self.board.password, timeout=5)

            # Open SFTP client
            with ssh.open_sftp() as sftp:

                try:
                    # Check if the parent directory of the
                    sftp.stat(os.path.dirname(self.remote_path))
                except FileNotFoundError:
                    raise Exception(f"The path {os.path.dirname(self.remote_path)} does not exist on the board")

                try:
                    # Delete the destination folder if it already exists on the board
                    sftp.stat(self.remote_path)
                    stdin, stdout, stderr = ssh.exec_command(f"sudo -S rm -rf {self.remote_path}")
                    stdin.write(f"{self.board.password}\n")
                    exit_status = stdout.channel.recv_exit_status()
                    self._print_ssh(stdout.read().decode(), end="")
                except FileNotFoundError:
                    # Nothing to delete
                    pass

                # Create directories on the board
                sftp.mkdir(self.remote_path)
                for directory in directories_to_create:
                    sftp.mkdir(os.path.join(self.remote_path, directory))

                # Copy files on the board
                for file in files_to_transfer:
                    sftp.put(os.path.join(self.local_path, file), os.path.join(self.remote_path, file))

        print("DONE")

    def modify_deploy_folder(self, fpga_freq_mhz=100.0):
        """Modify the instantiation of FINNExampleOverlay in the driver.py file of the 'deploy' directory to add
        the clock frequency, so that the throughput_test exec_mode of the remote_execute returns the good metrics"""
        with open(os.path.join(self.local_path, "driver", "driver.py"), 'r') as f:
            lines = f.readlines()

        for i, line in enumerate(lines):
            if "FINNExampleOverlay(" in line:
                if not "fclk_mhz" in lines[i+1]:
                    lines.insert(i+1, f"        fclk_mhz = {fpga_freq_mhz},\n")
                    break

        with open(os.path.join(self.local_path, "driver", "driver.py"), 'w') as f:
            f.writelines(lines)

    def execute(self, image: np.ndarray, exec_mode: str="execute", timeout: int=60):
        """
        This function remote_execute performs a remote execution of a Python script called driver.py on a board,
        which takes an input image as an argument, and returns the output of the script.
        The output can either be a numpy array or a dictionary (in JSON format), depending on the
        exec_mode parameter.
        :param image: A numpy array representing the input image
        :param exec_mode:  A string representing the mode of execution of the driver.py script.
        It can be either "execute" or "throughput_test". Default value is "execute".
        :param timeout: An integer representing the maximum amount of time to wait for the driver.py script to complete
        its execution before timing out. Default value is 60 seconds.
        :return: A numpy array containing the output of the neural network inference if the exec_mode is "execute",
        else a dictionary that contains the results of the throughput measurement
        """
        assert exec_mode in ("execute", "throughput_test")
        output_file = "output.npy" if exec_mode == "execute" else "nw_metrics.txt"

        # Remove local input.npy and output file
        for file in ("input.npy", output_file):
            if os.path.exists(os.path.join(self.local_path, "driver", file)):
                os.remove(os.path.join(self.local_path, "driver", file))

        # Save input image as a numpy file
        np.save(os.path.join(self.local_path, "driver", "input"), image)

        print(f"{exec_mode} on board...", end="")
        with SSHClient() as ssh:
            ssh.set_missing_host_key_policy(AutoAddPolicy())
            # Connect to the board with a timeout of 5 seconds
            ssh.connect(self.board.ip, self.board.port, self.board.username, self.board.password, timeout=5)

            # Transfer the input image to the board
            with ssh.open_sftp() as sftp:
                sftp.put(os.path.join(self.local_path, "driver", "input.npy"),
                         os.path.join(self.remote_path, "driver", "input.npy"))

            # Remote inference
            cmd1 = f"cd {self.remote_path}/driver"
            cmd2 = f"sudo -S python3 driver.py --bitfile ../bitfile/finn-accel.bit --exec_mode {exec_mode}"
            stdin, stdout, stderr = ssh.exec_command(f"{cmd1} ; {cmd2}")
            stdin.write(f"{self.board.password}\n")

            # Wait until it is over or timeout is reached
            cnt = 0
            while not stdout.channel.exit_status_ready():
                time.sleep(1)
                cnt += 1
                if cnt >= timeout:
                    raise Exception(
                        f"The execution of driver.py on the board hangs. Try to increase the timeout, "
                        f"or manually debug the driver.py and execute this command on the board to confirm:\n"
                        f"{cmd1} ; {cmd2}\n"
                    )
            print("DONE")

            # Eventually print the output
            self._print_ssh(stdout.read().decode())

            # Get output result
            with ssh.open_sftp() as sftp:
                sftp.get(os.path.join(self.remote_path, "driver", output_file),
                         os.path.join(self.local_path, "driver", output_file))

        if exec_mode == "execute":
            # Load the output of the neural network inference as a numpy array
            result = np.load(os.path.join(self.local_path, "driver", output_file))
        else:
            # Load the  as a dictionary
            with open(os.path.join(self.local_path, "driver", output_file), "r") as file:
                file_content = file.read()
            result = json.loads(file_content.replace("'", "\""))

        return result
